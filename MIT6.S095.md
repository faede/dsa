# 1.You Will All comfrom

## question：
每个人都是知道他们的号码，从0开始，一群人排队，带着帽子，朝向前或后，你可以选定一个人反转帽子，或者让一个区间的人反转帽子。最终使得队列中所有人的帽子朝向一个方向。min操作次数

0 1 2 3  4  5  6  7   8    9   10

F B B F  B  F  F  B  B    B    F

1 to 2 (inclusive) flip

4 flip

7 to 9 filp

forward [0,0]   [3,3] [5 ,6] [10,10]   : 4

backword [1,2] [4,4] [7,9]                :3  <----少的

## answer A：遍历序列，找出所有连续的序列分为先前和向后两列，反转区间多的。（两次遍历，第一次统计，第二次输出）

因为每一个连续的F或者B总是被一起反转的，因为最终的朝向相同，所以显然一次反转更优。

并且每次反转只会有F，B，假如某次反转中有F和B，（显然会出现在中央）不妨设为FFFBF，要将它反转为B，

那么第一次BBBFB，第二次BBBBB，假如有两个FBFBF,第一次BFBFB,BBBFB,BBBBB。需要三次反转，这与只反转F是相同的。

## answerB（只需要遍历一次）:

加一个 'end'作为结尾，

加a[0]作为结尾。

你会发现与第0个人方向不同的间隔个数，最多与和第一个人方向相同的人的间隔数相同。

两个人显然成立。

下面证明任意人都成立：

否则考虑序列T，开头是F，那么要让B的间隔数目多于F的间隔数目。那么只能加B，并且前一个是F（否则就会被归为前一个连续的操作），但是当T的开头和结尾都为F时，连续（或单个）的F分开了B，此时F的间隔个数 = B的间隔个数+1，加上新增的间隔数，此时F，B的间隔数相同。

所以只需要将于开头不同方向的连续的人反转。

当a[i] != a[i-1]时反转，并判断当前字符是否与开头相同，输出。

优化的算法只需要一次遍历，增加尾哨兵节点a[0]，就可以不用处理特殊情况。





## 	Puzzle 3:The Best Time To The Party

你有参加一张参加聚会的票，这张票的时间是灵活的，在你离开之前，你要和其他人交流，你可以选择你去交流的时间，你有一张时间表，表上记录了参加聚会的人的时间，选择固定的时间（1）最大化交流的人数。

Celeb    |     Comes     |     Gones    

Beyonce         6                     7                [ 6,7)   

Talyor             7                      9

Brad                 10               11

Kaly                10                   12

Tom                 8                   10

Drake              9                    11

Allua                 6                     8



### A

朴素，区间改，查询最大值。O(n*n)

### B

sort进入时间，离开时间。

看到人就+1，出去-1

O(nlogn)

(感觉桶排O(n) ?)

进一步，最优总产生在有人进入的时间、，因为总是在进入时增加，而不可能选择出去的时间。



## Puzzle 3: You Can Read Minds

52张牌。

B会读心术，5个人每个人从52个扑克牌，各自选择一个，然后B助手的向B展示4张：（比如第一张是红心K，.....)然后B就可以猜出第五张是什么
问：
B如何做到的?助手是会配合B的。





5张牌，鸽巢原理一定有一张牌花色相同。




























# 1.You Will All comfrom

## question：
每个人都是知道他们的号码，从0开始，一群人排队，带着帽子，朝向前或后，你可以选定一个人反转帽子，或者让一个区间的人反转帽子。最终使得队列中所有人的帽子朝向一个方向。min操作次数

0 1 2 3 4 5 6 7 8 9   10

F B B F B F F B  B    F

1 to 2 (inclusive) flip

4 flip

7 to 9 filp

forward [0,0]   [3,3] [5 ,6] [10,10]   : 4

backword [1,2] [4,4] [7,9]                :3  <----少的

## answer A：遍历序列，找出所有连续的序列分为先前和向后两列，反转区间多的。（两次遍历，第一次统计，第二次输出）

因为每一个连续的F或者B总是被一起反转的，因为最终的朝向相同，所以显然一次反转更优。

并且每次反转只会有F，B，假如某次反转中有F和B，（显然会出现在中央）不妨设为FFFBF，要将它反转为B，

那么第一次BBBFB，第二次BBBBB，假如有两个FBFBF,第一次BFBFB,BBBFB,BBBBB。需要三次反转，这与只反转F是相同的。

## answerB（只需要遍历一次）:

加一个 'end'作为结尾，

加a[0]作为结尾。

你会发现与第0个人方向不同的间隔个数，最多与和第一个人方向相同的人的间隔数相同。

两个人显然成立。

下面证明任意人都成立：

否则考虑序列T，开头是F，那么要让B的间隔数目多于F的间隔数目。那么只能加B，并且前一个是F（否则就会被归为前一个连续的操作），但是当T的开头和结尾都为F时，连续（或单个）的F分开了B，此时F的间隔个数 = B的间隔个数+1，加上新增的间隔数，此时F，B的间隔数相同。

所以只需要将于开头不同方向的连续的人反转。

当a[i] != a[i-1]时反转，并判断当前字符是否与开头相同，输出。

优化的算法只需要一次遍历，增加尾哨兵节点a[0]，就可以不用处理特殊情况。






